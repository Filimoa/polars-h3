{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This is a Polars extension that adds support for the H3 discrete global grid system, so you can index points and geometries to hexagons directly in Polars. All credits goes to the h3o for doing the heavy lifting.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li> <p>\ud83d\ude80 Blazing Fast: Built entirely in Rust, offering vectorized, multi-core H3 operations within Polars. Ideal for high-performance data processing.</p> </li> <li> <p>25X faster than h3-py</p> </li> <li> <p>5X faster than H3 DuckDB (See notebook for more details)</p> </li> <li> <p>\ud83c\udf0d H3 Feature Parity: Comprehensive support for H3 functions, covering almost everything the standard H3 library provides, excluding geometric functions.</p> </li> <li> <p>\ud83d\udccb Fully Tested: Accurately tested against the standard H3 library.</p> </li> <li> <p>\ud83d\udd0d Data Type Agnostic: Supports string and integer H3 indexes natively, eliminating format conversion hassles.</p> </li> </ul>"},{"location":"#get-started","title":"Get started","text":"<p>You can get started by installing it with pip (or uv):</p> <pre><code>pip install polars-h3\n</code></pre> <p>You can use the extension as a drop-in replacement for the standard H3 functions.</p> <pre><code>import polars_h3 as plh3\nimport polars as pl\n\n&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"lat\": [37.7749],\n...         \"long\": [-122.4194],\n...     }\n... ).with_columns(\n...     plh3.latlng_to_cell(\n...         \"lat\",\n...         \"long\",\n...         resolution=7,\n...         return_dtype=pl.Utf8\n...     ).alias(\"h3_cell\"),\n... )\n&gt;&gt;&gt; df\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lat     \u2506 long      \u2506 h3_cell         \u2502\n\u2502 ---     \u2506 ---       \u2506 ---             \u2502\n\u2502 f64     \u2506 f64       \u2506 str             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 37.7749 \u2506 -122.4194 \u2506 872830828ffffff \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Check out the quickstart notebook for more examples.</p> <p>You can also find the advanced notebooks here.</p>"},{"location":"#implemented-functions","title":"Implemented functions","text":"<p>This extension implements most of the H3 API. The full list of functions is below.</p> <p>\u26a0\ufe0f Performance Note: When possible, prefer using <code>pl.UInt64</code> for H3 indices instead of the <code>pl.Utf8</code> representation. String representations require casting operations which impact performance. Working directly with the native 64-bit integer format provides better computational efficiency.</p> <p>We are unable to support the functions that work with geometries.</p>"},{"location":"#full-list-of-functions","title":"Full list of functions","text":"<p>\u2705 = Supported \ud83d\udea7 = Pending \ud83d\uded1 = Not supported</p>"},{"location":"#full-list-of-functions_1","title":"Full list of functions","text":"Function Description Supported <code>latlng_to_cell</code> Convert latitude/longitude coordinates to an H3 cell index. \u2705 <code>cell_to_lat</code> Extract the latitude coordinate from H3 cell indices. \u2705 <code>cell_to_lng</code> Extract the longitude coordinate from H3 cell indices. \u2705 <code>cell_to_latlng</code> Convert H3 cells into a list of <code>[latitude, longitude]</code>. \u2705 <code>cell_to_local_ij</code> Convert an H3 cell index into its local IJ coordinates, relative to a given origin. \u2705 <code>local_ij_to_cell</code> Convert local IJ coordinates back into an H3 cell index. \u2705 <code>cell_to_boundary</code> Retrieve the polygon boundary coordinates of the given H3 cell. \u2705 <code>are_neighbor_cells</code> Check if two H3 cells share a common edge. \u2705 <code>cells_to_directed_edge</code> Create a directed H3 edge from two neighboring cells. \u2705 <code>is_valid_directed_edge</code> Check if an H3 index is a valid directed edge. \u2705 <code>directed_edge_to_cells</code> Retrieve the origin/destination cells from a directed edge. \u2705 <code>get_directed_edge_origin</code> Extract the origin cell from a directed H3 edge. \u2705 <code>get_directed_edge_destination</code> Extract the destination cell from a directed H3 edge. \u2705 <code>origin_to_directed_edges</code> List all directed edges originating from a given cell. \u2705 <code>directed_edge_to_boundary</code> Retrieve the geographic boundary (list of lat/lng pairs) for a directed edge. \u2705 <code>get_resolution</code> Retrieve the resolution of H3 indices (cells, edges, or vertices). \u2705 <code>str_to_int</code> Convert string-based H3 indices into <code>UInt64</code> representation. \u2705 <code>int_to_str</code> Convert integer-based H3 indices into string form. \u2705 <code>is_valid_cell</code> Check if H3 cell indices are valid. \u2705 <code>is_pentagon</code> Determine if an H3 cell is a pentagon. \u2705 <code>is_res_class_III</code> Check if H3 cells belong to Class III resolution. \u2705 <code>get_icosahedron_faces</code> Retrieve the icosahedron faces intersected by an H3 cell. \u2705 <code>cell_to_parent</code> Retrieve the parent cell of a given H3 cell at a specified resolution. \u2705 <code>cell_to_center_child</code> Retrieve the \u201ccenter child\u201d of an H3 cell at a finer resolution. \u2705 <code>cell_to_children_size</code> Get the number of child cells at a given resolution. \u2705 <code>cell_to_children</code> Retrieve all child cells at a specified resolution. \u2705 <code>cell_to_child_pos</code> Get the position index of a child cell within its parent hierarchy. \u2705 <code>child_pos_to_cell</code> Get the child cell at a given position index for a specified parent/resolution. \u2705 <code>compact_cells</code> Compact a set of H3 cells into a minimal covering set. \u2705 <code>uncompact_cells</code> Uncompact a set of H3 cells to the specified resolution. \u2705 <code>great_circle_distance</code> Compute the Haversine distance between two sets of lat/lng coordinates. \u2705 <code>average_hexagon_area</code> Get the average area of an H3 hexagon at a given resolution. \u2705 <code>cell_area</code> Get the area of a specific H3 cell. \u2705 <code>edge_length</code> Get the length of an H3 edge cell (currently raises <code>NotImplementedError</code>). \ud83d\udea7 <code>average_hexagon_edge_length</code> Get the average edge length for hexagons at a given resolution. \u2705 <code>get_num_cells</code> Get the total number of H3 cells at a given resolution. \u2705 <code>get_pentagons</code> Get the number of pentagons at a given resolution (currently raises <code>NotImplementedError</code>). \ud83d\udea7 <code>grid_distance</code> Compute the grid distance (minimum steps) between two H3 cells. \u2705 <code>grid_ring</code> Produce a \u201chollow ring\u201d of cells at distance <code>k</code> from the origin cell. \u2705 <code>grid_disk</code> Produce a \u201cfilled disk\u201d of cells within distance <code>k</code> of an origin cell. \u2705 <code>grid_path_cells</code> Return the minimal path of cells connecting an origin and destination. \u2705 <code>cell_to_vertex</code> Retrieve the H3 vertex index for a specific vertex of a given cell. \u2705 <code>cell_to_vertexes</code> Retrieve all vertex indices for a given H3 cell (5 for pentagon, 6 for hex). \u2705 <code>vertex_to_latlng</code> Convert an H3 vertex index into its latitude/longitude coordinates. \u2705 <code>is_valid_vertex</code> Check whether an H3 index represents a valid vertex. \u2705 <code>cells_to_multi_polygon_wkt</code> Convert a set of cells to multipolygon WKT. \ud83d\uded1 (Not supported) <code>polygon_wkt_to_cells</code> Convert polygon WKT to a set of cells. \ud83d\uded1 (Not supported) <code>directed_edge_to_boundary_wkt</code> Convert directed edge ID to linestring WKT. \ud83d\uded1 (Not supported)"},{"location":"#plotting","title":"Plotting","text":"<p>The library also comes with helper functions to plot hexes on a Folium map.</p> <pre><code>import polars_h3 as pl_h3\nimport polars as pl\n\nhex_map = pl_h3.graphing.plot_hex_outlines(df, \"h3_cell\")\ndisplay(hex_map)\n\n# or if you have a metric to plot\n\nhex_map = pl_h3.graphing.plot_hex_fills(df, \"h3_cell\", \"metric_col\")\ndisplay(hex_map)\n</code></pre> <p></p>"},{"location":"#development","title":"Development","text":"<p>It's recommended to use uv to manage the extension dependencies. If you modify rust code, you will need to run <code>uv run maturin develop --uv</code> to see changes. If you're looking to benchmark the performance of the extension, build the release version with <code>maturin develop --release --uv</code> and then run <code>uv run -m benchmarks.engine</code> (assuming you have the benchmark dependencies installed). Benchmarking with the development version will lead to misleading results.</p>"},{"location":"graphing/","title":"Folium Integration","text":"<p>Functions that use Folium to visualize H3 cells on a map.</p>"},{"location":"graphing/#plot_hex_outlines","title":"<code>plot_hex_outlines</code>","text":"<p>Plot hexagon outlines on a Folium map.</p> <pre><code>plot_hex_outlines(\n    df: pl.DataFrame,\n    hex_id_col: str,\n    map: Any | None = None,\n    outline_color: str = \"red\",\n    map_size: Literal[\"medium\", \"large\"] = \"medium\",\n) -&gt; Any\n</code></pre> <p>Parameters</p> <ul> <li>df : pl.DataFrame   A DataFrame that must contain a column of H3 cell IDs.</li> <li>hex_id_col : str   Column name in <code>df</code> containing H3 cell IDs (hexagon identifiers).</li> <li>map : folium.Map or None   An existing Folium map object on which to plot. If <code>None</code>, a new map is created.</li> <li>outline_color : str   Color used to outline the hexagons. Defaults to <code>\"red\"</code>.</li> <li>map_size : <code>{\"medium\", \"large\"}</code>   The size of the displayed map. <code>\"medium\"</code> sets width and height to 50%; <code>\"large\"</code> sets them to 100%.</li> </ul> <p>Returns</p> <ul> <li>Any   A Folium map object with hexagon outlines added.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"hex_id\": [599686042433355775, 599686042433355776]\n... })\n&gt;&gt;&gt; # Suppose 'hex_id' contains valid H3 cell indices\n&gt;&gt;&gt; my_map = polars_h3_folium.plot_hex_outlines(df, \"hex_id\", outline_color=\"blue\")\n&gt;&gt;&gt; my_map\n</code></pre> <p>Errors</p> <ul> <li><code>ValueError</code> : If the input DataFrame is empty.</li> <li><code>ImportError</code> : If <code>folium</code> is not installed.</li> </ul>"},{"location":"graphing/#plot_hex_fills","title":"<code>plot_hex_fills</code>","text":"<p>Render filled hexagonal cells on a Folium map, colorized by a specified metric.</p> <pre><code>plot_hex_fills(\n    df: pl.DataFrame,\n    hex_id_col: str,\n    metric_col: str,\n    map: Any | None = None,\n    map_size: Literal[\"medium\", \"large\"] = \"medium\",\n) -&gt; Any\n</code></pre> <p>Parameters</p> <ul> <li>df : pl.DataFrame   A DataFrame that must contain columns for H3 cell IDs and a metric to color by.</li> <li>hex_id_col : str   Column name containing H3 cell IDs.</li> <li>metric_col : str   Column name containing metric values for colorization.</li> <li>map : folium.Map or None   An existing Folium map object. If <code>None</code>, a new map is created.</li> <li>map_size : <code>{\"medium\", \"large\"}</code>   The size of the displayed map. <code>\"medium\"</code> sets 50% width/height, <code>\"large\"</code> sets 100%.</li> </ul> <p>Returns</p> <ul> <li>Any   A Folium map object with filled hexagons colorized by the specified metric.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"hex_id\": [599686042433355775, 599686042433355776],\n...     \"some_metric\": [10.0, 42.0],\n... })\n&gt;&gt;&gt; # 'hex_id' and 'some_metric' must be valid\n&gt;&gt;&gt; my_map = polars_h3_folium.plot_hex_fills(df, \"hex_id\", \"some_metric\")\n&gt;&gt;&gt; my_map\n</code></pre> <p></p> <p>Errors</p> <ul> <li><code>ValueError</code> : If the input DataFrame is empty.</li> <li><code>ImportError</code> : If <code>folium</code> or <code>matplotlib</code> is not installed.</li> </ul> <p>Note These functions leverage Folium for mapping and Matplotlib for color scaling in <code>plot_hex_fills</code>. Ensure both are installed to visualize your hexes properly.</p>"},{"location":"api-reference/edge/","title":"Directed edge functions","text":"<p>Directed edges allow encoding the directed (that is, which cell is the origin and which is the destination can be determined) edge from one cell to a neighboring cell.</p>"},{"location":"api-reference/edge/#are_neighbor_cells","title":"<code>are_neighbor_cells</code>","text":"<p>Determine whether two H3 cells are neighbors.</p> <pre><code>plh3.are_neighbor_cells(\n    origin: IntoExprColumn,\n    destination: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>origin : IntoExprColumn   H3 cell index serving as the origin (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>destination : IntoExprColumn   H3 cell index serving as the destination (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A boolean Polars expression: <code>true</code> if the cells share an edge, <code>false</code> otherwise.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"cell1\": [599686042433355775],\n...     \"cell2\": [599686030622195711],\n... })\n&gt;&gt;&gt; df.with_columns(neighbors=plh3.are_neighbor_cells(\"cell1\", \"cell2\"))\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 cell1               \u2502 cell2               \u2502 neighbors \u2502\n\u2502 ---                 \u2502 ---                 \u2502 ---       \u2502\n\u2502 u64                 \u2502 u64                 \u2502 bool      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 599686030622195711  \u2502 true      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If invalid or null indices are provided.</li> </ul>"},{"location":"api-reference/edge/#cells_to_directed_edge","title":"<code>cells_to_directed_edge</code>","text":"<p>Create a directed H3 edge from two neighboring cells.</p> <pre><code>plh3.cells_to_directed_edge(\n    origin: IntoExprColumn,\n    destination: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>origin : IntoExprColumn   Origin H3 cell index.</li> <li>destination : IntoExprColumn   Destination H3 cell index.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the H3 directed edge index.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"origin\": [599686042433355775],\n...     \"destination\": [599686030622195711],\n... })\n&gt;&gt;&gt; df.with_columns(edge=plh3.cells_to_directed_edge(\"origin\", \"destination\"))\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 origin              \u2502 destination         \u2502 edge                \u2502\n\u2502 ---                 \u2502 ---                 \u2502 ---                 \u2502\n\u2502 u64                 \u2502 u64                 \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 599686030622195711  \u2502 1608492358964346879 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If the cells are not neighbors or invalid.</li> </ul>"},{"location":"api-reference/edge/#is_valid_directed_edge","title":"<code>is_valid_directed_edge</code>","text":"<p>Check if an H3 index is a valid directed edge.</p> <pre><code>plh3.is_valid_directed_edge(\n    edge: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>edge : IntoExprColumn   H3 index to validate.</li> </ul> <p>Returns</p> <ul> <li>Expr   A boolean Polars expression: <code>true</code> if <code>edge</code> is a valid directed edge, <code>false</code> otherwise.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"edge\": [\"115283473fffffff\"]})\n&gt;&gt;&gt; df.with_columns(valid=plh3.is_valid_directed_edge(\"edge\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge                  \u2502 valid    \u2502\n\u2502 ---                   \u2502 ---      \u2502\n\u2502 str                   \u2502 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 115283473fffffff      \u2502 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If the input is invalid or null.</li> </ul>"},{"location":"api-reference/edge/#get_directed_edge_origin","title":"<code>get_directed_edge_origin</code>","text":"<p>Extract the origin cell from a directed H3 edge.</p> <pre><code>plh3.get_directed_edge_origin(\n    edge: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>edge : IntoExprColumn   H3 directed edge index.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the origin cell (<code>pl.UInt64</code> or <code>pl.Utf8</code>).</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"edge\": [1608492358964346879]})\n&gt;&gt;&gt; df.with_columns(origin=plh3.get_directed_edge_origin(\"edge\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge                \u2502 origin              \u2502\n\u2502 ---                 \u2502 ---                 \u2502\n\u2502 u64                 \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1608492358964346879 \u2502 599686042433355775  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If <code>edge</code> is invalid or null.</li> </ul>"},{"location":"api-reference/edge/#get_directed_edge_destination","title":"<code>get_directed_edge_destination</code>","text":"<p>Extract the destination cell from a directed H3 edge.</p> <pre><code>plh3.get_directed_edge_destination(\n    edge: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>edge : IntoExprColumn   H3 directed edge index.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the destination cell (<code>pl.UInt64</code> or <code>pl.Utf8</code>).</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"edge\": [1608492358964346879]})\n&gt;&gt;&gt; df.with_columns(destination=plh3.get_directed_edge_destination(\"edge\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge                \u2502 destination         \u2502\n\u2502 ---                 \u2502 ---                 \u2502\n\u2502 u64                 \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1608492358964346879 \u2502 599686030622195711  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If <code>edge</code> is invalid or null.</li> </ul>"},{"location":"api-reference/edge/#directed_edge_to_cells","title":"<code>directed_edge_to_cells</code>","text":"<p>Retrieve the origin-destination cell pair from a directed edge.</p> <pre><code>plh3.directed_edge_to_cells(\n    edge: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>edge : IntoExprColumn   H3 directed edge index.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning <code>[origin, destination]</code> as <code>[pl.UInt64, pl.UInt64]</code> (or <code>[pl.Utf8, pl.Utf8]</code>).</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"edge\": [1608492358964346879]})\n&gt;&gt;&gt; df.with_columns(cells=plh3.directed_edge_to_cells(\"edge\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge                \u2502 cells               \u2502\n\u2502 ---                 \u2502 ---                 \u2502\n\u2502 u64                 \u2502 list[u64]           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1608492358964346879 \u2502 [599686042433355775,\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If <code>edge</code> is invalid or null.</li> </ul>"},{"location":"api-reference/edge/#origin_to_directed_edges","title":"<code>origin_to_directed_edges</code>","text":"<p>List all directed edges originating from a given cell.</p> <pre><code>plh3.origin_to_directed_edges(\n    cell: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index serving as the origin.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of directed edges (<code>pl.UInt64</code> or <code>pl.Utf8</code>).</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [599686042433355775]})\n&gt;&gt;&gt; df.with_columns(edges=plh3.origin_to_directed_edges(\"h3_cell\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 edges                           \u2502\n\u2502 ---                 \u2502 ---                             \u2502\n\u2502 u64                 \u2502 list[u64]                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 [1608492358964346879,\u2026]          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If <code>cell</code> is invalid or null.</li> </ul>"},{"location":"api-reference/edge/#directed_edge_to_boundary","title":"<code>directed_edge_to_boundary</code>","text":"<p>Retrieve the geographic boundary (list of lat/lng pairs) defining a directed edge.</p> <pre><code>plh3.directed_edge_to_boundary(\n    edge: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>edge : IntoExprColumn   H3 directed edge index.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of <code>[lat, lng]</code> pairs, each itself a two-element list.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"edge\": [1608492358964346879]})\n&gt;&gt;&gt; df.with_columns(boundary=plh3.directed_edge_to_boundary(\"edge\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 edge                \u2502 boundary                      \u2502\n\u2502 ---                 \u2502 ---                           \u2502\n\u2502 u64                 \u2502 list[list[f64]]               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1608492358964346879 \u2502 [[37.3457, -121.9763], \u2026 ]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If <code>edge</code> is invalid, null, or its boundary cannot be computed.</li> </ul>"},{"location":"api-reference/indexing/","title":"Indexing functions","text":"<p>These functions are used for finding the H3 cell index containing coordinates, and for finding the center and boundary of H3 cells.</p>"},{"location":"api-reference/indexing/#latlng_to_cell","title":"<code>latlng_to_cell</code>","text":"<p>Convert latitude/longitude coordinates to H3 cell indices.</p> <pre><code>plh3.latlng_to_cell(\n    lat: IntoExprColumn,\n    lng: IntoExprColumn,\n    resolution: HexResolution,\n    return_dtype: type[pl.Utf8] | type[pl.UInt64] | type[pl.Int64] = pl.UInt64\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>lat : IntoExprColumn   Column/expression containing latitude values (as <code>pl.Float64</code>).</li> <li>lng : IntoExprColumn   Column/expression containing longitude values (as <code>pl.Float64</code>).</li> <li>resolution : int in <code>[0, 15]</code>   H3 resolution level.</li> <li>return_dtype : <code>pl.UInt64</code> | <code>pl.Int64</code> | <code>pl.Utf8</code>   Desired return type for the H3 index (defaults to <code>pl.UInt64</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning H3 cell indices in the specified format.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"lat\": [37.7752702151959],\n...     \"lng\": [-122.418307270836]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     h3_cell=plh3.latlng_to_cell(\"lat\", \"lng\", resolution=9, return_dtype=pl.Utf8)\n... )\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lat              \u2502 lng                \u2502 h3_cell          \u2502\n\u2502 ---              \u2502 ---                \u2502 ---              \u2502\n\u2502 f64              \u2502 f64                \u2502 str              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 37.7752702151959 \u2502 -122.418307270836  \u2502 8928308280fffff   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; # Using integer output\n&gt;&gt;&gt; df.with_columns(\n...     h3_cell=plh3.latlng_to_cell(\"lat\", \"lng\", resolution=1, return_dtype=pl.UInt64)\n... )\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lat     \u2502 lng      \u2502 h3_cell             \u2502\n\u2502 ---     \u2502 ---      \u2502 ---                 \u2502\n\u2502 f64     \u2502 f64      \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0.0     \u2502 0.0      \u2502 583031433791012863  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ValueError</code>: If the <code>resolution</code> is not in <code>[0, 15]</code>.</li> <li><code>ComputeError</code>: If input coordinates contain null values or are otherwise invalid.</li> </ul>"},{"location":"api-reference/indexing/#cell_to_lat","title":"<code>cell_to_lat</code>","text":"<p>Extract the latitude coordinate from H3 cell indices.</p> <pre><code>plh3.cell_to_lat(\n    cell: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   Column/expression containing H3 cell indices (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning latitude values as <code>Float64</code>.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [\"85283473fffffff\"]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     lat=plh3.cell_to_lat(\"h3_cell\"),\n...     lng=plh3.cell_to_lng(\"h3_cell\")\n... )\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell          \u2502 lat             \u2502 lng               \u2502\n\u2502 ---              \u2502 ---             \u2502 ---               \u2502\n\u2502 str              \u2502 f64             \u2502 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 85283473fffffff  \u2502 37.345793375368 \u2502 -121.976375972551 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; # Works with integer representation too\n&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [599686042433355775]}, schema={\"h3_cell\": pl.UInt64})\n&gt;&gt;&gt; df.with_columns(\n...     lat=plh3.cell_to_lat(\"h3_cell\"),\n...     lng=plh3.cell_to_lng(\"h3_cell\")\n... )\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 lat             \u2502 lng               \u2502\n\u2502 ---                 \u2502 ---             \u2502 ---               \u2502\n\u2502 u64                 \u2502 f64             \u2502 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 37.345793375368 \u2502 -121.976375972551 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/indexing/#cell_to_lng","title":"<code>cell_to_lng</code>","text":"<p>Extract the longitude coordinate from H3 cell indices.</p> <pre><code>plh3.cell_to_lng(\n    cell: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   Column/expression containing H3 cell indices (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning longitude values as <code>Float64</code>.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [\"85283473fffffff\"]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     lat=plh3.cell_to_lat(\"h3_cell\"),\n...     lng=plh3.cell_to_lng(\"h3_cell\")\n... )\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell          \u2502 lat             \u2502 lng               \u2502\n\u2502 ---              \u2502 ---             \u2502 ---               \u2502\n\u2502 str              \u2502 f64             \u2502 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 85283473fffffff  \u2502 37.345793375368 \u2502 -121.976375972551 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; # Works with integer representation too\n&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [599686042433355775]}, schema={\"h3_cell\": pl.UInt64})\n&gt;&gt;&gt; df.with_columns(\n...     lat=plh3.cell_to_lat(\"h3_cell\"),\n...     lng=plh3.cell_to_lng(\"h3_cell\")\n... )\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 lat             \u2502 lng               \u2502\n\u2502 ---                 \u2502 ---             \u2502 ---               \u2502\n\u2502 u64                 \u2502 f64             \u2502 f64               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 37.345793375368 \u2502 -121.976375972551 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/indexing/#cell_to_latlng","title":"<code>cell_to_latlng</code>","text":"<p>Convert H3 cells into a list of <code>[latitude, longitude]</code>.</p> <pre><code>plh3.cell_to_latlng(\n    cell: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   Column/expression containing H3 cell indices (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A list of floats <code>[lat, lng]</code> for each H3 cell.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"cell\": [\"85283473fffffff\"]})\n&gt;&gt;&gt; df.select(plh3.cell_to_latlng(\"cell\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 cell_to_latlng          \u2502\n\u2502 ---                     \u2502\n\u2502 list[f64]               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [37.3457934, -121.9763\u2026]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; # Easily extract lat/lng as separate columns:\n&gt;&gt;&gt; df.select([\n...     plh3.cell_to_latlng(\"cell\").arr.get(0).alias(\"lat\"),\n...     plh3.cell_to_latlng(\"cell\").arr.get(1).alias(\"lng\"),\n... ])\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lat       \u2502 lng       \u2502\n\u2502 ---       \u2502 ---       \u2502\n\u2502 f64       \u2502 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 37.345793\u2026\u2502 -121.9763\u2026\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If null or invalid H3 cell indices are encountered.</li> </ul>"},{"location":"api-reference/indexing/#cell_to_local_ij","title":"<code>cell_to_local_ij</code>","text":"<p>Convert an H3 cell index into its local IJ coordinates relative to a given origin.</p> <pre><code>plh3.cell_to_local_ij(\n    cell: IntoExprColumn,\n    origin: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index to convert (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>origin : IntoExprColumn   Origin H3 cell index in the local IJ space.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list <code>[i, j]</code> of integer coordinates.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"origin\": [599686042433355775],\n...     \"cell\": [599686042433355776]\n... })\n&gt;&gt;&gt; df.select(plh3.cell_to_local_ij(\"cell\", \"origin\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 cell_to_local_ij\u2502\n\u2502 ---            \u2502\n\u2502 list[i64]      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [0,1]          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If the inputs are invalid, null, or cannot be transformed.</li> </ul>"},{"location":"api-reference/indexing/#local_ij_to_cell","title":"<code>local_ij_to_cell</code>","text":"<p>Convert local IJ coordinates back into an H3 cell index using a given origin.</p> <pre><code>plh3.local_ij_to_cell(\n    origin: IntoExprColumn,\n    i: IntoExprColumn,\n    j: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>origin : IntoExprColumn   The H3 cell index defining the local IJ space.</li> <li>i : IntoExprColumn   The local i-coordinate (row).</li> <li>j : IntoExprColumn   The local j-coordinate (column).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the corresponding H3 cell index.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"origin\": [599686042433355775],\n...     \"i\": [0],\n...     \"j\": [1]\n... })\n&gt;&gt;&gt; df.select(plh3.local_ij_to_cell(\"origin\", \"i\", \"j\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 local_ij_to_cell\u2502\n\u2502 ---             \u2502\n\u2502 u64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355776 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If null or invalid inputs are encountered, or the transformation cannot be performed.</li> </ul>"},{"location":"api-reference/indexing/#cell_to_boundary","title":"<code>cell_to_boundary</code>","text":"<p>Retrieve the polygon boundary coordinates of the given H3 cell.</p> <pre><code>plh3.cell_to_boundary(\n    cell: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell indices (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of <code>Float64</code> values representing <code>[lat0, lng0, lat1, lng1, \u2026]</code>.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"cell\": [\"8a1fb464492ffff\"]\n... })\n&gt;&gt;&gt; df.select(plh3.cell_to_boundary(\"cell\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 cell_to_boundary                  \u2502\n\u2502 ---                                \u2502\n\u2502 list[f64]                          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [[50.99, -76.05], [48.29, -81.91...\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If null or invalid H3 cell indices are encountered.</li> </ul>"},{"location":"api-reference/inspection/","title":"Inspection functions","text":"<p>These functions provide metadata about an H3 index, such as its resolution or base cell, and provide utilities for converting into and out of the 64-bit representation of an H3 index.</p>"},{"location":"api-reference/inspection/#get_resolution","title":"<code>get_resolution</code>","text":"<p>Retrieve the resolution of H3 indices (cells, edges, or vertices).</p> <pre><code>plh3.get_resolution(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   Column/expression containing H3 indices (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression yielding an integer resolution (<code>0\u201315</code>) for each H3 index.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [599686042433355775]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     resolution=plh3.get_resolution(\"h3_cell\")\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 resolution \u2502\n\u2502 ---                 \u2502 ---        \u2502\n\u2502 u64                 \u2502 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 2          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#str_to_int","title":"<code>str_to_int</code>","text":"<p>Convert string H3 indices into their unsigned 64-bit integer representation.</p> <pre><code>plh3.str_to_int(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   String-based H3 cells (e.g., <code>\"85283473fffffff\"</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression yielding <code>pl.UInt64</code> indices, or <code>null</code> for invalid strings.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_str\": [\"85283473fffffff\", \"invalid_index\"]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     h3_int=plh3.str_to_int(\"h3_str\")\n... )\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_str           \u2502 h3_int              \u2502\n\u2502 ---              \u2502 ---                 \u2502\n\u2502 str              \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 85283473fffffff  \u2502 599686042433355775  \u2502\n\u2502 invalid_index    \u2502 null                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#int_to_str","title":"<code>int_to_str</code>","text":"<p>Convert integer H3 indices into their string representation.</p> <pre><code>plh3.int_to_str(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   Integer-based H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression yielding string representations of H3 indices, or <code>null</code> for invalid inputs.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_int\": [599686042433355775, -1]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     h3_str=plh3.int_to_str(\"h3_int\")\n... )\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_int              \u2502 h3_str           \u2502\n\u2502 ---                 \u2502 ---              \u2502\n\u2502 u64                 \u2502 str              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 85283473fffffff  \u2502\n\u2502 -1                  \u2502 null             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#is_valid_cell","title":"<code>is_valid_cell</code>","text":"<p>Check if H3 cell indices are valid.</p> <pre><code>plh3.is_valid_cell(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A boolean Polars expression: <code>true</code> if valid, <code>false</code> otherwise.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [\"85283473fffffff\", \"invalid_cell\"]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     valid=plh3.is_valid_cell(\"h3_cell\")\n... )\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 valid \u2502\n\u2502 ---                 \u2502 ---   \u2502\n\u2502 str                 \u2502 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 85283473fffffff     \u2502 true  \u2502\n\u2502 invalid_cell        \u2502 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#is_pentagon","title":"<code>is_pentagon</code>","text":"<p>Determine if H3 cells are pentagons.</p> <pre><code>plh3.is_pentagon(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A boolean Polars expression indicating if each H3 cell is a pentagon.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [585961082523222015, 599686042433355775]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     is_pent=plh3.is_pentagon(\"h3_cell\")\n... )\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 is_pent \u2502\n\u2502 ---                 \u2502 ---     \u2502\n\u2502 u64                 \u2502 bool    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 585961082523222015  \u2502 true    \u2502\n\u2502 599686042433355775  \u2502 false   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#is_res_class_iii","title":"<code>is_res_class_III</code>","text":"<p>Check if H3 cells belong to the Class III resolution set.</p> <pre><code>plh3.is_res_class_III(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A boolean Polars expression indicating if each cell is Class III.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [582692784209657855, 586265647244115967]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     is_class_3=plh3.is_res_class_III(\"h3_cell\")\n... )\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 is_class_3 \u2502\n\u2502 ---                 \u2502 ---        \u2502\n\u2502 u64                 \u2502 bool       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 582692784209657855  \u2502 true       \u2502\n\u2502 586265647244115967  \u2502 false      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#get_icosahedron_faces","title":"<code>get_icosahedron_faces</code>","text":"<p>Retrieve the icosahedron faces intersected by an H3 cell.</p> <pre><code>plh3.get_icosahedron_faces(\n    expr: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>expr : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of intersected face indices.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cell\": [599686042433355775]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     faces=plh3.get_icosahedron_faces(\"h3_cell\")\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 faces   \u2502\n\u2502 ---                 \u2502 ---     \u2502\n\u2502 u64                 \u2502 list[i64]\u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 [7]     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#cell_to_parent","title":"<code>cell_to_parent</code>","text":"<p>Retrieve the parent cell of a given H3 cell at a specified resolution.</p> <pre><code>plh3.cell_to_parent(\n    cell: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>resolution : int in <code>[0, 15]</code>   Target parent resolution.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the parent cell.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [599686042433355775]})\n&gt;&gt;&gt; df.with_columns(\n...     parent=plh3.cell_to_parent(\"h3_cell\", 1)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 parent              \u2502\n\u2502 ---                 \u2502 ---                 \u2502\n\u2502 u64                 \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 593686042413355775  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#cell_to_center_child","title":"<code>cell_to_center_child</code>","text":"<p>Retrieve the center child cell of an H3 cell at a specified resolution.</p> <pre><code>plh3.cell_to_center_child(\n    cell: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>resolution : int in <code>[0, 15]</code></li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the center child cell at the given resolution.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [582692784209657855]})\n&gt;&gt;&gt; df.with_columns(\n...     center_child=plh3.cell_to_center_child(\"h3_cell\", 2)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 center_child    \u2502\n\u2502 ---                 \u2502 ---             \u2502\n\u2502 u64                 \u2502 u64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 582692784209657855  \u2502 ...             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#cell_to_children_size","title":"<code>cell_to_children_size</code>","text":"<p>Get the number of children cells at a specified resolution.</p> <pre><code>plh3.cell_to_children_size(\n    cell: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>resolution : int in <code>[0, 15]</code></li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the number of children cells.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [582692784209657855]})\n&gt;&gt;&gt; df.with_columns(\n...     num_children=plh3.cell_to_children_size(\"h3_cell\", 2)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 num_children \u2502\n\u2502 ---                 \u2502 ---          \u2502\n\u2502 u64                 \u2502 u64          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 582692784209657855  \u2502 7            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#cell_to_children","title":"<code>cell_to_children</code>","text":"<p>Retrieve all children cells of an H3 cell at a specified resolution.</p> <pre><code>plh3.cell_to_children(\n    cell: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>resolution : int in <code>[0, 15]</code></li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of child cells at the given resolution.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [582692784209657855]})\n&gt;&gt;&gt; df.with_columns(\n...     children=plh3.cell_to_children(\"h3_cell\", 2)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 children                          \u2502\n\u2502 ---                 \u2502 ---                               \u2502\n\u2502 u64                 \u2502 list[u64]                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 582692784209657855  \u2502 [587192535546331135, ...]         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#cell_to_child_pos","title":"<code>cell_to_child_pos</code>","text":"<p>Get the position index of a child cell within its parent cell hierarchy.</p> <pre><code>plh3.cell_to_child_pos(\n    cell: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>resolution : int in <code>[0, 15]</code></li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the child cell\u2019s position index.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [582692784209657855]})\n&gt;&gt;&gt; df.with_columns(\n...     child_pos=plh3.cell_to_child_pos(\"h3_cell\", 2)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 child_pos \u2502\n\u2502 ---                 \u2502 ---       \u2502\n\u2502 u64                 \u2502 u64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 582692784209657855  \u2502 0       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#child_pos_to_cell","title":"<code>child_pos_to_cell</code>","text":"<p>Obtain the child cell at a given position index for a specified parent cell and resolution.</p> <pre><code>plh3.child_pos_to_cell(\n    parent: IntoExprColumn,\n    pos: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>parent : IntoExprColumn   H3 cell index (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>pos : IntoExprColumn   Position index (<code>pl.UInt64</code> or <code>pl.Int64</code>).</li> <li>resolution : int in <code>[0, 15]</code></li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the child cell at the given position.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"parent\": [582692784209657855],\n...     \"pos\": [0]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     child=plh3.child_pos_to_cell(\"parent\", \"pos\", 2)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 parent              \u2502 child    \u2502\n\u2502 ---                 \u2502 ---      \u2502\n\u2502 u64                 \u2502 u64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 582692784209657855  \u2502 ...      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#compact_cells","title":"<code>compact_cells</code>","text":"<p>Compact a set of H3 cells into a minimal covering set.</p> <pre><code>plh3.compact_cells(\n    cells: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cells : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>), possibly in a list.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a compacted list of H3 cells.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"h3_cells\": [[599686042433355775, 599686042433355776]]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     compact=plh3.compact_cells(\"h3_cells\")\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cells                          \u2502 compact                        \u2502\n\u2502 ---                               \u2502 ---                            \u2502\n\u2502 list[u64]                         \u2502 list[u64]                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [599686042433355775, 5996860424\u2026] \u2502 [599686042433355775]           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/inspection/#uncompact_cells","title":"<code>uncompact_cells</code>","text":"<p>Uncompact a set of H3 cells to the specified resolution.</p> <pre><code>plh3.uncompact_cells(\n    cells: IntoExprColumn,\n    resolution: HexResolution\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cells : IntoExprColumn   H3 cells (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>resolution : int in <code>[0, 15]</code></li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of H3 cells at the specified resolution.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"compact_cells\": [[582692784209657855]]\n... })\n&gt;&gt;&gt; df.with_columns(\n...     full_set=plh3.uncompact_cells(\"compact_cells\", 2)\n... )\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 compact_cells        \u2502 full_set                       \u2502\n\u2502 ---                  \u2502 ---                            \u2502\n\u2502 list[u64]            \u2502 list[u64]                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [582692784209657855] \u2502 [587192535546331135, ...]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Notes</p> <ul> <li>A <code>ComputeError</code> may occur if inputs are invalid or the operation cannot be completed.</li> <li>A <code>ValueError</code> is raised if the <code>resolution</code> is outside <code>[0, 15]</code>.</li> </ul>"},{"location":"api-reference/metrics/","title":"Metrics","text":""},{"location":"api-reference/metrics/#great_circle_distance","title":"<code>great_circle_distance</code>","text":"<p>Compute the Haversine distance between two latitude/longitude pairs.</p> <pre><code>plh3.great_circle_distance(\n    s_lat_deg: IntoExprColumn,\n    s_lng_deg: IntoExprColumn,\n    e_lat_deg: IntoExprColumn,\n    e_lng_deg: IntoExprColumn,\n    unit: Literal[\"km\", \"m\"] = \"km\"\n) -&gt; pl.Expr\n</code></pre> <p>Description Uses the Haversine formula to approximate the great circle distance on Earth\u2019s surface. The error is usually much smaller than 0.5% for typical use cases.</p> <p>Parameters</p> <ul> <li>s_lat_deg : IntoExprColumn   Starting latitude in degrees (as <code>pl.Float64</code>).</li> <li>s_lng_deg : IntoExprColumn   Starting longitude in degrees (as <code>pl.Float64</code>).</li> <li>e_lat_deg : IntoExprColumn   Ending latitude in degrees (as <code>pl.Float64</code>).</li> <li>e_lng_deg : IntoExprColumn   Ending longitude in degrees (as <code>pl.Float64</code>).</li> <li>unit : <code>{\"km\", \"m\"}</code>   Unit of the returned distance. Defaults to kilometers.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the great circle distance between the two points.</li> </ul> <p>Examples</p> <pre><code>df = pl.DataFrame({\n    \"start_lat\": [37.775],\n    \"start_lng\": [-122.419],\n    \"end_lat\": [40.7128],\n    \"end_lng\": [-74.0060],\n})\ndf.with_columns(\n    distance=plh3.great_circle_distance(\n        \"start_lat\", \"start_lng\", \"end_lat\", \"end_lng\", unit=\"km\"\n    )\n)\n</code></pre>"},{"location":"api-reference/metrics/#average_hexagon_area","title":"<code>average_hexagon_area</code>","text":"<p>Return the average area of an H3 hexagon at a given resolution.</p> <pre><code>plh3.average_hexagon_area(\n    resolution: IntoExprColumn,\n    unit: Literal[\"km^2\", \"m^2\"] = \"km^2\"\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>resolution : IntoExprColumn   H3 resolution level (<code>0</code> to <code>15</code>).</li> <li>unit : <code>{\"km^2\", \"m^2\"}</code>   Unit of the returned area. Defaults to square kilometers (<code>\"km^2\"</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the average hexagon area at the given resolution.</li> </ul> <p>Examples</p> <pre><code>df = pl.DataFrame({\"resolution\": [5]})\ndf.with_columns(\n    area=plh3.average_hexagon_area(\"resolution\", \"km^2\")\n)\n</code></pre>"},{"location":"api-reference/metrics/#cell_area","title":"<code>cell_area</code>","text":"<p>Get the area of a specific H3 cell.</p> <pre><code>plh3.cell_area(\n    cell: IntoExprColumn,\n    unit: Literal[\"km^2\", \"m^2\"] = \"km^2\"\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index (as <code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>unit : <code>{\"km^2\", \"m^2\"}</code>   Unit of the returned area. Defaults to square kilometers.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the area of the H3 cell.</li> </ul> <p>Note: This function calls into a plugin that is elementwise. For invalid inputs, a <code>ComputeError</code> may be raised.</p>"},{"location":"api-reference/metrics/#edge_length","title":"<code>edge_length</code>","text":"<p>Determine the length of an H3 edge cell.</p> <pre><code>plh3.edge_length(\n    cell: IntoExprColumn,\n    unit: Literal[\"km\", \"m\"] = \"km\"\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 index representing an edge (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>unit : <code>{\"km\", \"m\"}</code>   Unit of the returned length. Defaults to kilometers.</li> </ul> <p>Returns</p> <ul> <li>Expr   Once implemented, it should return a Polars expression with the length of the edge.</li> </ul>"},{"location":"api-reference/metrics/#average_hexagon_edge_length","title":"<code>average_hexagon_edge_length</code>","text":"<p>Get the average edge length of H3 hexagons at a specific resolution.</p> <pre><code>plh3.average_hexagon_edge_length(\n    resolution: IntoExprColumn,\n    unit: Literal[\"km\", \"m\"] = \"km\"\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>resolution : IntoExprColumn   H3 resolution level (<code>0</code> to <code>15</code>).</li> <li>unit : <code>{\"km\", \"m\"}</code>   Unit of the returned length. Defaults to kilometers.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the average edge length for hexagons at the specified resolution.</li> </ul> <p>Examples</p> <pre><code>df = pl.DataFrame({\"resolution\": [1]})\ndf.with_columns(\n    length=plh3.average_hexagon_edge_length(\"resolution\", \"km\")\n)\n</code></pre>"},{"location":"api-reference/metrics/#get_num_cells","title":"<code>get_num_cells</code>","text":"<p>Get the total number of H3 cells at a given resolution.</p> <pre><code>plh3.get_num_cells(\n    resolution: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>resolution : IntoExprColumn   H3 resolution level (<code>0</code> to <code>15</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the number of unique cells at the given resolution.</li> </ul> <p>Examples</p> <pre><code>df = pl.DataFrame({\"resolution\": [5]})\ndf.with_columns(\n    count=plh3.get_num_cells(\"resolution\")\n)\n</code></pre>"},{"location":"api-reference/metrics/#get_pentagons","title":"<code>get_pentagons</code>","text":"<p>Get the number of pentagons at a given resolution.</p> <pre><code>plh3.get_pentagons(\n    resolution: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>resolution : IntoExprColumn   H3 resolution level (<code>0</code> to <code>15</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   Once implemented, it should return a Polars expression with the count of pentagonal cells at the specified resolution.</li> </ul> <p>Note</p> <ul> <li>Many of these functions will raise a <code>ComputeError</code> if given invalid input or null values.</li> <li>Functions requiring a specific <code>resolution</code> will also raise a <code>ValueError</code> for out-of-range resolutions (<code>&lt; 0</code> or <code>&gt; 15</code>).</li> <li>The <code>edge_length</code> and <code>get_pentagons</code> functions are placeholders that raise <code>NotImplementedError</code>.</li> </ul>"},{"location":"api-reference/traversal/","title":"Grid traversal functions","text":"<p>Grid traversal allows finding cells in the vicinity of an origin cell, and determining how to traverse the grid from one cell to another.</p>"},{"location":"api-reference/traversal/#grid_distance","title":"<code>grid_distance</code>","text":"<p>Compute the grid distance between two H3 cells.</p> <pre><code>plh3.grid_distance(\n    origin: IntoExprColumn,\n    destination: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>origin : IntoExprColumn   H3 cell index (as <code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>destination : IntoExprColumn   H3 cell index (as <code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the minimum number of steps between <code>origin</code> and <code>destination</code>, or <code>null</code> if it cannot be computed.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"start\": [605035864166236159],\n...     \"end\": [605034941150920703],\n... })\n&gt;&gt;&gt; df.select(plh3.grid_distance(\"start\", \"end\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 grid_distance \u2502\n\u2502 ---           \u2502\n\u2502 i64           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If inputs are invalid (e.g. different resolutions or pentagon issues).</li> <li>Returns <code>None</code>: If no valid distance can be computed.</li> </ul>"},{"location":"api-reference/traversal/#grid_ring","title":"<code>grid_ring</code>","text":"<p>Produce a \"hollow ring\" of cells at exactly grid distance <code>k</code> from the origin cell.</p> <pre><code>plh3.grid_ring(\n    cell: IntoExprColumn,\n    k: int | IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index (as <code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>k : int | IntoExprColumn   The ring distance. Must be non-negative.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of H3 cells at distance <code>k</code>. May contain <code>null</code> items if pentagonal distortion is encountered.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"input\": [622054503267303423]})\n&gt;&gt;&gt; df.select(plh3.grid_ring(\"input\", 1))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 grid_ring                         \u2502\n\u2502 ---                               \u2502\n\u2502 list[u64]                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [622054502770606079, 622054502770\u2026]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"input\": [622054503267303423], \"k\": [1]})\n&gt;&gt;&gt; df.select(plh3.grid_ring(\"input\", \"k\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 grid_ring                         \u2502\n\u2502 ---                               \u2502\n\u2502 list[u64]                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [622054502770606079, 622054502770\u2026]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Returns</p> <ul> <li><code>ValueError</code>: If <code>k &lt; 0</code>.</li> <li><code>ComputeError</code>: If pentagonal distortion or invalid inputs prevent computation.</li> </ul>"},{"location":"api-reference/traversal/#grid_disk","title":"<code>grid_disk</code>","text":"<p>Produce a \u201cfilled-in disk\u201d of cells within grid distance <code>k</code> of the origin cell.</p> <pre><code>plh3.grid_disk(\n    cell: IntoExprColumn,\n    k: int | IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index (as <code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>k : int | IntoExprColumn   The maximum distance from the origin. Must be non-negative.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of H3 cells from distance 0 up to <code>k</code>.   May contain <code>null</code> items if pentagonal distortion is encountered.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"input\": [622054503267303423]})\n&gt;&gt;&gt; df.select(plh3.grid_disk(\"input\", 1))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 grid_disk                         \u2502\n\u2502 ---                               \u2502\n\u2502 list[u64]                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [622054503267303423, 622054502770\u2026]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"input\": [622054503267303423], \"k\": [1]})\n&gt;&gt;&gt; df.select(plh3.grid_disk(\"input\", \"k\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 grid_disk                         \u2502\n\u2502 ---                               \u2502\n\u2502 list[u64]                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [622054503267303423, 622054502770\u2026]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Returns</p> <ul> <li><code>ValueError</code>: If <code>k &lt; 0</code>.</li> <li><code>ComputeError</code>: If pentagonal distortion or invalid inputs prevent computation.</li> </ul>"},{"location":"api-reference/traversal/#grid_path_cells","title":"<code>grid_path_cells</code>","text":"<p>Find a minimal contiguous path of cells from <code>origin</code> to <code>destination</code>.</p> <pre><code>plh3.grid_path_cells(\n    origin: IntoExprColumn,\n    destination: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>origin : IntoExprColumn   H3 cell index for the starting cell.</li> <li>destination : IntoExprColumn   H3 cell index for the ending cell.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of H3 cells forming a minimal path from <code>origin</code> to <code>destination</code>, or <code>null</code> if no valid path is found.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"start\": [605035864166236159],\n...     \"end\": [605034941150920703],\n... })\n&gt;&gt;&gt; df.select(plh3.grid_path_cells(\"start\", \"end\"))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 grid_path_cells                   \u2502\n\u2502 ---                               \u2502\n\u2502 list[u64]                         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [605035864166236159, 605035861750\u2026]\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Returns</p> <ul> <li><code>ComputeError</code>: If no valid path can be computed (e.g., due to invalid inputs or pentagon issues).</li> </ul>"},{"location":"api-reference/vertexes/","title":"Vertex functions","text":"<p>Vertex mode allows encoding the topological vertexes of H3 cells.</p>"},{"location":"api-reference/vertexes/#cell_to_vertex","title":"<code>cell_to_vertex</code>","text":"<p>Retrieve the H3 vertex index for a specific vertex of a given cell.</p> <pre><code>plh3.cell_to_vertex(\n    cell: IntoExprColumn,\n    vertex_num: int\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> <li>vertex_num : int   0-based vertex number. For hexagonal cells, valid range is <code>[0..5]</code>; for pentagonal cells, <code>[0..4]</code>.</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning the corresponding H3 vertex index (<code>pl.UInt64</code> or <code>pl.Int64</code>), or <code>null</code> if invalid.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [599686042433355775]})\n&gt;&gt;&gt; df.with_columns(vertex=plh3.cell_to_vertex(\"h3_cell\", 0))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 vertex              \u2502\n\u2502 ---                 \u2502 ---                 \u2502\n\u2502 u64                 \u2502 u64                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 2473183459502194687 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Errors</p> <ul> <li><code>ComputeError</code>: If <code>vertex_num</code> is out of range or the cell is invalid.</li> </ul>"},{"location":"api-reference/vertexes/#cell_to_vertexes","title":"<code>cell_to_vertexes</code>","text":"<p>Retrieve all vertex indices for a given H3 cell.</p> <pre><code>plh3.cell_to_vertexes(\n    cell: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>cell : IntoExprColumn   H3 cell index (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a list of H3 vertex indices (6 for a hex cell, 5 for a pentagon).</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"h3_cell\": [599686042433355775]})\n&gt;&gt;&gt; df.with_columns(vertexes=plh3.cell_to_vertexes(\"h3_cell\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 h3_cell             \u2502 vertexes                                       \u2502\n\u2502 ---                 \u2502 ---                                             \u2502\n\u2502 u64                 \u2502 list[u64]                                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 599686042433355775  \u2502 [2473183459502194687, 2545241069646249983, \u2026 ] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/vertexes/#vertex_to_latlng","title":"<code>vertex_to_latlng</code>","text":"<p>Convert an H3 vertex index into its latitude and longitude coordinates.</p> <pre><code>plh3.vertex_to_latlng(\n    vertex: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>vertex : IntoExprColumn   H3 vertex index (<code>pl.UInt64</code>, <code>pl.Int64</code>, or <code>pl.Utf8</code>).</li> </ul> <p>Returns</p> <ul> <li>Expr   A Polars expression returning a two-element list <code>[latitude, longitude]</code> (<code>Float64</code>, <code>Float64</code>) or <code>null</code> if invalid.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"vertex\": [2459626752788398079]})\n&gt;&gt;&gt; df.with_columns(coords=plh3.vertex_to_latlng(\"vertex\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex               \u2502 coords                  \u2502\n\u2502 ---                  \u2502 ---                     \u2502\n\u2502 u64                  \u2502 list[f64]               \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2459626752788398079  \u2502 [39.38084284181812, 88.57496213785487] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/vertexes/#is_valid_vertex","title":"<code>is_valid_vertex</code>","text":"<p>Check whether an H3 index represents a valid H3 vertex.</p> <pre><code>plh3.is_valid_vertex(\n    vertex: IntoExprColumn\n) -&gt; pl.Expr\n</code></pre> <p>Parameters</p> <ul> <li>vertex : IntoExprColumn   H3 vertex index.</li> </ul> <p>Returns</p> <ul> <li>Expr   A boolean Polars expression: <code>true</code> if valid, <code>false</code> otherwise.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"vertex\": [2459626752788398079]})\n&gt;&gt;&gt; df.with_columns(valid=plh3.is_valid_vertex(\"vertex\"))\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 vertex               \u2502 valid    \u2502\n\u2502 ---                  \u2502 ---      \u2502\n\u2502 u64                  \u2502 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2459626752788398079  \u2502 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"}]}